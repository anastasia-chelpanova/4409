#include <random>
#include <stdexcept>
#include <algorithm>

#include "Sample.hpp"

 /**
  * Функция создает выборку заданного размера, где каждое число равномерно
  * распределено в диапазоне [minVal, maxVal]. Для генерации используется
  * аппаратный генератор случайных чисел (std::random_device) для инициализации
  * генератора псевдослучайных чисел Мерсенна (std::mt19937).
  *
  * Принцип работы:
  * 1. Проверяется корректность диапазона (минимум не должен превышать максимум).
  * 2. Инициализируется движок генерации случайных чисел.
  * 3. Настраивается равномерное распределение (uniform_real_distribution).
  * 4. Заполняется вектор результата путем последовательного вызова генератора.
  *
  * count Количество элементов в генерируемой выборке.
  * minVal Минимальное возможное значение (включительно).
  * maxVal Максимальное возможное значение (включительно).
  *
  * Результат: Вектор, содержащий 'count' случайных чисел.
  *
  * Выбрасывает исключение std::invalid_argument если minVal > maxVal.
  */
std::vector<float> GenerateSample(
    size_t count,
    float minVal,
    float maxVal)
{
    // Проверка валидности входного диапазона
    if (minVal > maxVal) {
        throw std::invalid_argument("The minimum value cannot be greater than the maximum.");
    }

    // std::random_device используется для получения начального значения (seed)
    std::random_device rd;
    // std::mt19937 — быстрый и качественный генератор псевдослучайных чисел 
    std::mt19937 gen(rd());
    // Распределение задает диапазон значений, которые будет возвращать генератор
    std::uniform_real_distribution<float> dist(minVal, maxVal);

    // Предварительное выделение памяти под результат для избежания реаллокаций
    std::vector<float> result(count);
    // Заполнение вектора случайными числами
    for (size_t i = 0; i < count; ++i) {
        result[i] = dist(gen);
    }

    return result;
}

/**
 * Функция проходит по всем элементам вектора и считает, сколько из них
 * удовлетворяют условию: элемент < value.
 *
 * Принцип работы:
 * Используется стандартный алгоритм std::count_if, который принимает
 * итераторы начала и конца диапазона, а также предикат (условие).
 * В качестве предиката используется лямбда-выражение, захватывающее
 * переменную 'value' по значению.
 *
 * sample Константная ссылка на вектор с данными для анализа.
 * value Пороговое значение для сравнения.
 *
 * Результат: Количество элементов, удовлетворяющих условию (x < value).
 */
size_t CountLessThan(
    const std::vector<float>& sample,
    float value)
{
    // std::count_if применяет предикат к каждому элементу диапазона
    // и возвращает количество элементов, для которых предикат вернул true.
    return std::count_if(sample.begin(), sample.end(),
        [value]         // Захват переменной value по значению в лямбда-функцию
        (float x)       // Аргумент лямбда-функции — текущий элемент вектора
        { 
            return x < value;   // Условие: элемент должен быть строго меньше порога
        });
}

/**
 * Функция суммирует ИНДЕКСЫ (позиции) элементов,
 * значения которых меньше нуля.
 *
 * Принцип работы:
 * 1. Осуществляется линейный проход по вектору с использованием индекса.
 * 2. Для каждого элемента проверяется условие: sample[i] < 0.0f.
 * 3. Если условие истинно, текущий индекс 'i' добавляется к накопительной сумме.
 *
 * sample Константная ссылка на вектор с данными для анализа.
 *
 * Результат: size_t Сумма индексов отрицательных элементов.
 *         Если отрицательных элементов нет, возвращается 0.
 */
size_t SumNegativeIndices(
    const std::vector<float>& sample) 
{
    size_t sum = 0;

    // Цикл по индексу необходим, так как нам нужно значение самого индекса
    // для добавления в сумму, а не только значение элемента.
    for (size_t i = 0; i < sample.size(); ++i) {
        // Проверка на отрицательное значение элемента
        if (sample[i] < 0.0f) {
            // Добавляем текущий индекс к общей сумме
            sum += i;
        }
    }

    return sum;
}
